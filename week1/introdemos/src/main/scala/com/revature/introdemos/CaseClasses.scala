package com.revature.introdemos

object CaseClasses {
  def run() = {
    //case classes provide automatically generated functionality on top of normal classes
    // case classes are often used when writing FP style code, because by default case classes
    // are immutable and have some useful autogenerated methods

    //our case class Fruit works as an immutable record of Fruit objects.

    //case classes generate an apply() method on the companion object
    // This apply method is used instead of the constructor to create new instance of the case class
    val lemon = Fruit(
      "yellow",
      44
    ) //apply method of automatically generated companion object Fruit
    val apple = Fruit("red", 2) //another one

    println(lemon) //case classes generate a toString

    //case classes generate a copy() method on the class, that lets us make modified copies of our objects
    val lime = lemon.copy(color="green")
    println(lime)

    //case classes generate an unapply method, which is used to get the following functionality in match-case expression:
    lime match {
      case Fruit(color, sourness) => {}
    }

    val cheddar = Cheese(0, 0)
    List[Food](lime, cheddar, lemon).foreach((f:Food) => {
      f match {
        case Fruit(color, sourness) => {println(s"Fruit with color $color and sourness $sourness")}
        case Cheese(age, stinkiness) => {println(s"Cheese with age $age and stinkiness $stinkiness")}
      }
    })

    //case classes have sensible implementations of equals (checking equality of fields) and hashcode (produces a number based on field values)
    println(lime.equals(lemon))
    println(lime.equals(lime.copy()))
    println(lime.hashCode())
    println(lemon.hashCode())
    //if 2 objects are .equals to each other, they should have the same hashcode
    // if 2 objects have the same hashcode, they are not necessarily .equals to each other
    // it's a desirable property of .hashCode for it to produce different numbers for different objects

    // Fruit("yellow", 44) and Fruit("yellow", 44) MUST produce the same hashcode
    // Fruit("yellow", 44) annd Fruit("aubergine", 927549204) MIGHT produce the same hashcode, but probably not
    // ^ its better for us if these do not produce the same hashcode, but guaranteeing unique hashcodes is too costly
    // hashCodes are used in hash tables

    // case classes are immutable and have 6 generated methods.  We'll use case classes often, whenever we need to
    // represent some structured pieces of data and tuples aren't good enough

    //some playing around with regular classes + companion objects to reproduce case class functionality
    val broccoli = Veggie("green", 10) //using our apply method
    println(broccoli)
    val cauliflower = new Veggie("white", 2) //using the constructor directly

    //class extending case class? maybe functional but confusing
    val blueberry = new Berry("blue", 5)

  }

  class Food {}

  case class Fruit(color: String, sourness: Int) extends Food {}

  case class Cheese(age: Int, stinkiness: Int) extends Food {}

  class Berry(color: String, sourness: Int) extends Fruit(color, sourness) {}


  //not a case class, just a class
  class Veggie(color: String, tastiness: Int) {
    
  }

  //companion object for Veggie
  object Veggie {
    //similar to autogenerated apply method you get from a case class:
    def apply(color: String, tastiness: Int) = {
      new Veggie(color, tastiness)
    }
  }

}
